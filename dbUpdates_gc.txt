/** for prod move **/

DROP PROCEDURE `universaltranslator`.`addCharToString`;
DROP PROCEDURE `universaltranslator`.`addDelimiterEvery2Characters`;
DROP PROCEDURE `universaltranslator`.`AlphaNumericCheck`;
DROP PROCEDURE `universaltranslator`.`AlphaNumericCheck_20200422`;
DROP PROCEDURE `universaltranslator`.`appendPrependString`;
DROP PROCEDURE `universaltranslator`.`appendPrependStringIfNotBlank`;
DROP PROCEDURE `universaltranslator`.`appendStringWithCon1IfLengthMataches`;
DROP PROCEDURE `universaltranslator`.`applyCW`;
DROP PROCEDURE `universaltranslator`.`applyCWTranslatedList`;
DROP PROCEDURE `universaltranslator`.`applyCWTranslatedListNoTrackDroppedValues`;
DROP PROCEDURE `universaltranslator`.`ArithmeticConstant`;
DROP PROCEDURE `universaltranslator`.`ArithmeticConstantStoreInFA`;
DROP PROCEDURE `universaltranslator`.`ArithmeticForSFAndFAUpdateFB`;
DROP PROCEDURE `universaltranslator`.`BHCounseling`;
DROP PROCEDURE `universaltranslator`.`BHMedServices`;
DROP PROCEDURE `universaltranslator`.`cat2ApplyCW`;
DROP PROCEDURE `universaltranslator`.`cat2ApplyCWForTransactionInRecords`;
DROP PROCEDURE `universaltranslator`.`cat2ApplyCWTranslatedList`;
DROP PROCEDURE `universaltranslator`.`cat2CleanListTable`;
DROP PROCEDURE `universaltranslator`.`cat2Concat2ColsDelimNoSpaces`;
DROP PROCEDURE `universaltranslator`.`cat2Concat3ColsDelimNoSpaces`;
DROP PROCEDURE `universaltranslator`.`cat2CopyColumnIn`;
DROP PROCEDURE `universaltranslator`.`cat2DelTransWhenFieldAIsNull`;
DROP PROCEDURE `universaltranslator`.`cat2PopulateTranslatedList`;
DROP PROCEDURE `universaltranslator`.`cat2StripLeadingChars`;
DROP PROCEDURE `universaltranslator`.`cat2StripLeadingCharsTTI`;
DROP PROCEDURE `universaltranslator`.`cat2UpdateListValue`;
DROP PROCEDURE `universaltranslator`.`CheckInvalidDateAndError`;
DROP PROCEDURE `universaltranslator`.`CheckLengthAndReplace`;
DROP PROCEDURE `universaltranslator`.`CheckListLengthIfGTError`;
DROP PROCEDURE `universaltranslator`.`CleanTranslatedListTable`;
DROP PROCEDURE `universaltranslator`.`closeOutReferral`;
DROP PROCEDURE `universaltranslator`.`CompareFALengthForNotBlankReplaceWithCon2`;
DROP PROCEDURE `universaltranslator`.`CompareTwoFieldsAndReject`;
DROP PROCEDURE `universaltranslator`.`Concat3ColsDelimNoSpaces`;
DROP PROCEDURE `universaltranslator`.`concat3ColssWithDelimiterNoSpaces`;
DROP PROCEDURE `universaltranslator`.`concatColumnsToList`;
DROP PROCEDURE `universaltranslator`.`concatFieldToList`;
DROP PROCEDURE `universaltranslator`.`copyColumn`;
DROP PROCEDURE `universaltranslator`.`CopyColumnTTItoTIR`;
DROP PROCEDURE `universaltranslator`.`countListSize`;
DROP PROCEDURE `universaltranslator`.`createTempErrorTable`;
DROP PROCEDURE `universaltranslator`.`dateddmonyyWithDashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datedmyyWithSlashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datemddyyyyToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datemddyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datemdyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datemmddyyWithSlashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datemmddyyyytoyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datemmddyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`datemmdyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS`;
DROP PROCEDURE `universaltranslator`.`dateyyyymmddTimeToDateTime`;
DROP PROCEDURE `universaltranslator`.`dateyyyymmddTommddyyyy`;
DROP PROCEDURE `universaltranslator`.`dateyyyymmddWithDashesToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`deleteTransaction`;
DROP PROCEDURE `universaltranslator`.`DeleteTransactionWhenFieldIsNull`;
DROP PROCEDURE `universaltranslator`.`DOBCheck`;
DROP PROCEDURE `universaltranslator`.`dropValueByPriorityInboundOnly`;
DROP PROCEDURE `universaltranslator`.`FALessThanNumericCon1UpdateFBwithCon2`;
DROP PROCEDURE `universaltranslator`.`FieldBGreaterThanEqualFieldAUpdateFieldA`;
DROP PROCEDURE `universaltranslator`.`futureDateCheck`;
DROP PROCEDURE `universaltranslator`.`getConfigToFromFieldNo`;
DROP PROCEDURE `universaltranslator`.`getFinalStatusIds`;
DROP PROCEDURE `universaltranslator`.`getJSONForConfig`;
DROP PROCEDURE `universaltranslator`.`GreaterThanEqualFieldAUpdateFieldB`;
DROP PROCEDURE `universaltranslator`.`if1Con1ElseCon2`;
DROP PROCEDURE `universaltranslator`.`if1Con1ElseNull`;
DROP PROCEDURE `universaltranslator`.`ifDateCon1ElseNull`;
DROP PROCEDURE `universaltranslator`.`IfFALengthNotMatchCon1ReplaceFBWithCon2`;
DROP PROCEDURE `universaltranslator`.`ifFAStartsWithCon1UpdateFBToCon2`;
DROP PROCEDURE `universaltranslator`.`IfFieldACon1andTFBlankInsertCon2Error`;
DROP PROCEDURE `universaltranslator`.`ifFieldANotCon1ThenNull`;
DROP PROCEDURE `universaltranslator`.`ifFieldANotInListValuesSetToCon2`;
DROP PROCEDURE `universaltranslator`.`ifFieldANotNumericSetFieldBToCon1`;
DROP PROCEDURE `universaltranslator`.`IfFieldsBlankThenError`;
DROP PROCEDURE `universaltranslator`.`IfMatchFieldAAndTFBlankSetTFValue`;
DROP PROCEDURE `universaltranslator`.`IfMatchSetToValueOfAnotherColumn`;
DROP PROCEDURE `universaltranslator`.`ifNonDateAndNotBlankReject`;
DROP PROCEDURE `universaltranslator`.`ifNonDateSetNull`;
DROP PROCEDURE `universaltranslator`.`ifNotBlankReject`;
DROP PROCEDURE `universaltranslator`.`ifNumLTThenError`;
DROP PROCEDURE `universaltranslator`.`IfSFLen0orNullReplaceValueInFA`;
DROP PROCEDURE `universaltranslator`.`ifSFMatchCon1ThenCon2ElseNull`;
DROP PROCEDURE `universaltranslator`.`IfSFNullOrEmptySetFieldBToValueFieldA`;
DROP PROCEDURE `universaltranslator`.`ifSrcFieldBlankAndFACompareTo0ThenFieldBCon2`;
DROP PROCEDURE `universaltranslator`.`insertValidationErrors`;
DROP PROCEDURE `universaltranslator`.`insertValidationErrorsOutbound`;
DROP PROCEDURE `universaltranslator`.`KeepTopRanked`;
DROP PROCEDURE `universaltranslator`.`lessThanEqualFieldAUpdateFieldB`;
DROP PROCEDURE `universaltranslator`.`ListToRows`;
DROP PROCEDURE `universaltranslator`.`MatchFAUpdateSF`;
DROP PROCEDURE `universaltranslator`.`MatchFieldAUpdateFieldB`;
DROP PROCEDURE `universaltranslator`.`mergeTransactions`;
DROP PROCEDURE `universaltranslator`.`mergeValues`;
DROP PROCEDURE `universaltranslator`.`mmddyyyytoyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`NJPopulateCounseling`;
DROP PROCEDURE `universaltranslator`.`NJProviderIdentifier`;
DROP PROCEDURE `universaltranslator`.`NotInUse_DateToyyyymmdd`;
DROP PROCEDURE `universaltranslator`.`NumericRange`;
DROP PROCEDURE `universaltranslator`.`overwriteColumn`;
DROP PROCEDURE `universaltranslator`.`overwriteColumnWithRandomNumber`;
DROP PROCEDURE `universaltranslator`.`pastDateCheck`;
DROP PROCEDURE `universaltranslator`.`populateAuditReport`;
DROP PROCEDURE `universaltranslator`.`populateDroppedValues`;
DROP PROCEDURE `universaltranslator`.`populateDroppedValues_20200610`;
DROP PROCEDURE `universaltranslator`.`populateOutboundAuditReport`;
DROP PROCEDURE `universaltranslator`.`PopulateTranslatedList`;
DROP PROCEDURE `universaltranslator`.`populateUniqueKeyAndTTI`;
DROP PROCEDURE `universaltranslator`.`populateWithBatchUploadId`;
DROP PROCEDURE `universaltranslator`.`prependStringWithCon2IfLengthMataches`;
DROP PROCEDURE `universaltranslator`.`regExCheck`;
DROP PROCEDURE `universaltranslator`.`rejectNonYearMonthTransactions`;
DROP PROCEDURE `universaltranslator`.`removeDupFromList`;
DROP PROCEDURE `universaltranslator`.`replaceBlanksWithChars`;
DROP PROCEDURE `universaltranslator`.`replacechars`;
DROP PROCEDURE `universaltranslator`.`setFieldToNull`;
DROP PROCEDURE `universaltranslator`.`setInboundOutBoundTables`;
DROP PROCEDURE `universaltranslator`.`setSqlForConfig`;
DROP PROCEDURE `universaltranslator`.`setSqlForOutboundConfig`;
DROP PROCEDURE `universaltranslator`.`stringToDate`;
DROP PROCEDURE `universaltranslator`.`StringToDateFor2DigitYears`;
DROP PROCEDURE `universaltranslator`.`stripCharAtPos`;
DROP PROCEDURE `universaltranslator`.`stripCharsFromStartOrEnd`;
DROP PROCEDURE `universaltranslator`.`stripLeadingChars`;
DROP PROCEDURE `universaltranslator`.`stripPhoneChars`;
DROP PROCEDURE `universaltranslator`.`stripPhoneCharsOutbound`;
DROP PROCEDURE `universaltranslator`.`stripTrailingChars`;
DROP PROCEDURE `universaltranslator`.`substringToAnotherField`;
DROP PROCEDURE `universaltranslator`.`trimField`;
DROP PROCEDURE `universaltranslator`.`updateFieldBToDistinctSrcFieldAsList`;
DROP PROCEDURE `universaltranslator`.`updateFieldBToSrcFieldAsList`;
DROP PROCEDURE `universaltranslator`.`UpdateFPRace`;
DROP PROCEDURE `universaltranslator`.`UpdateToMaxMinForCol`;
DROP PROCEDURE `universaltranslator`.`UpdateTranslatedListValueNotDistinct`;
DROP PROCEDURE `universaltranslator`.`YYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS`;
DROP PROCEDURE `universaltranslator`.`yyyymmddstripTime`;
DROP PROCEDURE `universaltranslator`.`yyyymmddTimeToDateTime`;
DROP PROCEDURE `universaltranslator`.`yyyymmddToDate`;
DROP PROCEDURE `universaltranslator`.`yyyymmddTommddyyyy`;
DROP PROCEDURE `universaltranslator`.`yyyymmddToString`;
DROP PROCEDURE `universaltranslator`.`ZipCodeCheck`;
DROP PROCEDURE `universaltranslator`.`ZipCodeCheck_20200422`;


-- misc tables still in the system

DROP TABLE if exists `universaltranslator`.`transactionindetailauditerrors_72`, `universaltranslator`.`transactioninerrors_72`, `universaltranslator`.`transactioninmacrodroppedvalues_72`, `universaltranslator`.`transactioninmacrokeptvalues_72`, `universaltranslator`.`transactioninrecords_67`, `universaltranslator`.`transactioninrecords_70`, `universaltranslator`.`transactioninrecords_71`, `universaltranslator`.`transactioninrecords_72`, `universaltranslator`.`transactiontranslatedin_72`, `universaltranslator`.`transactiontranslatedlistin_72`;


-- clean out macros table
truncate table macro_Names;

-- reinsert what is in stage
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES (1, 1, 'Conditional: IF SF = CON1, FB = CON2', 'IF SF = CON1, FB = CON2', NULL, NULL, 'MatchSFtoCon1UpdateFBtoCon2', NULL, '', 'Please enter the field number to update', 'Please enter the constant value to match the source field value.', 'Please enter the constant value to be inserted into field B if the match occurs.', 1, 'If the value in the field that the macro is attached to (SF) matches CON1, insert CON2 into the second field (FB). \r\n\r\nThis macrso does not generate an error under any circumstances.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('2', 1, 'Conditional: IF SFA = CON1, SF = CON2', 'IF SFA = CON1, SF = CON2', NULL, NULL, 'MatchFAtoCon1UpdateSFtoCon2', NULL, 'Please enter field number to match', NULL, 'Please enter constant to match', 'Please enter constant to update to', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('68', 1, 'Date - yyyy*mm*dd to mm*dd*yyyy', 'YYYY-MM-DD to MM-DD-YYYY', NULL, NULL, 'dateyyyymmddTommddyyyy', NULL, '', '', 'Please enter source SF\'s date value separator.  e.g. -, ., /', 'Please enter target SF\'s date value separator.  e.g. -, ., /', 1, 'This macro converts date value in yyyy-mm-dd format to mm-dd-yyyy. Any date value separators may be specified. \r\n\r\nIf an error occurs (i.e. date in wrong format), pass/clear logic will be applied and then reject record/reject file logic will be applied.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('69', 1, 'Date - mm*dd*yyyy to yyyy*mm*dd', 'MM-DD-YYYY to YYYY-MM-DD', NULL, NULL, 'datemmddyyyyToyyyymmdd', NULL, '', '', 'Please enter source SF\'s date value separator.  e.g. -, ., /', 'Please enter target SF\'s date value separator.  e.g. -, ., /', 1, 'This macro converts date value in mm-dd-yyyy format to yyyy-mm-dd. Any date value separators may be specified. \r\n\r\nIf an error occurs (i.e. date in wrong format), pass/clear logic will be applied and then reject record/reject file logic will be applied.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('70', 1, 'Set field to null', 'Clear SF', NULL, NULL, 'ClearSF', NULL, '', '', '', '', 1, 'Clear the field');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('72', 1, 'Replace chars in string', 'replaceChars1', NULL, NULL, 'replaceCon1CharswithCon2', NULL, '', '', 'Please enter character(s) that you would like to replace', 'Please enter new character(s).', 1, 'This macro searches for the CON1 character string in the current field and if found, replaces the character string with the specified character string in CON2.\r\n\r\nThis macro will never generate an error. If the specified character string is not found, the macro will move on to the next record.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('74', 1, 'Concat fields into delimited list', 'concat fields to list', NULL, NULL, 'concatFieldToList', NULL, '', '', 'Please enter delimiter', 'Please enter field numbers to be concatenated in a comma delimited list', 1, 'Concatenate the values found in the comma separated fields found in CON2 using the specified delimiter specified in CON1 and store the results into the current field.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('75', 1, 'Strip character at specific position of field, with optional character match', 'strip Char At Position X', NULL, NULL, 'stripCharAtPos', NULL, '', '', 'Please enter the position of the character to drop within the string', 'Please enter the character to drop (optional)', 1, 'In the current field, drop the character from the specified location in the character string. A specific character may be specified (optional). If a specific character is specified, and that character is not found, the character found is not dropped.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('76', 1, 'Match Null or empty value and replace', 'replace blanks with chars', NULL, NULL, 'replaceBlanksWithChars', NULL, '', '', 'Please enter the value to insert if the field is blank.', '', 1, 'This macro will nsert the specified value into the current field but only if the current field is blank or null.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('80', 1, 'Strip leading characters', 'Strip Leading', NULL, NULL, 'stripLeadingChars', NULL, '', '', 'Please enter leading character(s) to be removed', '', 1, 'This macro will strip characters specified by the user from the leading edge of the current field. If characters are not found, no action is taken.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('81', 1, 'Strip Trailing Character(s) from field', 'Strip trailing character', NULL, NULL, 'stripTrailingChars', NULL, '', '', 'Please enter trailing character(s) to remove', '', 1, 'This macro will strip characters specified by the user from the trailing edge of the current field. If characters are not found, no action is taken.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('86', 1, 'Update Field', 'Update Field', NULL, NULL, 'overwriteSF', NULL, '', '', 'Please enter new value to be stored in the current field.', '', 1, 'This macro replaces the value stored in the current field with the specified value.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('87', 1, 'Copy Field', 'Copy Field', NULL, NULL, 'copyField', NULL, '', 'Please enter the field number of the field to be copied into the current field.', '', '', 1, 'This macro copies the value from the specified field and stores that value in the current field.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('89', 1, 'Insert Random Number', 'Insert Random Nuimber', NULL, NULL, 'overwriteSFWithRandomNumber', NULL, '', '', '', NULL, 1, 'This macro inserts a random number into the current field.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('93', 1, 'Check Length of String and replace with', 'Check Length And Replace', NULL, NULL, 'CheckLengthAndReplace', NULL, '', '', 'Please enter minimum string length', 'Please enter the value to insert if string length is >= CON1', 1, 'This macro checks the lengfth of the value in the current field. If the length is >= CON1, the value specified in CON2 will be inserted.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('94', 1, 'Copy Substring to Another Field', 'Substring to Another Field', NULL, NULL, 'substringToAnotherField', NULL, 'Please enter field number to be updated', '', 'Please enter starting position of string to be extracted', 'Please enter how many characters to extract', 1, 'This macro copies a substring from the current field and stores that value in the specified field.\r\n\r\nThis macro never generates an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('99', 1, 'If scrField matches con1 overwrite Field A with Field B', 'If SRCF=CON1, Copy FB to FA', NULL, NULL, 'IfSFMatchCon1SetFAtoFB', NULL, 'Please enter field number to be updated', 'Please enter field number to copy to FA', 'Please enter value to match to SF', '', 1, 'This macro checks the current field for a specified value. If a match is found, the value in field B is copied to field A.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('102', 1, 'Prepend and/or Append Strings', 'Prepend Append String', NULL, NULL, 'appendPrependString', NULL, 'Please enter value you would like to prepend', 'Prepend if the field is blank (Y/N).', 'Please enter value you would like to append', 'Append if the field is blank (Y/N).', 1, 'This macro adds a string to the beginning and/or end to the field values in a column. Values that are empty or blank after white spaces are removed will be ignored.     An example is adding $ to the beginning, .00 to the end to all the values in column 1.  We would enter 1 for \'Please enter column to prepend or append to\'.    $ for \'Please enter value you would like to prepend\' and \'.00\' for \'Please enter value you would like to append\'.  For the sample value of 12, the macro converted value will be $12.00  ');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('103', 1, 'Check - Years Difference between Dates, i.e. DOB', 'yearDiffinsertError', NULL, NULL, 'yearDiffinsertError', NULL, 'Please enter the field for data to check against (e.g. visit date\'s column number)', NULL, 'Please enter the minium age before rejecting', '', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('104', 1, 'Check - Past Date', 'pastDateCheck', NULL, NULL, 'pastDateCheck', NULL, NULL, NULL, 'Please enter number of months', '', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('108', 1, 'Update SRCF to CON2 when SRCF is blank and FA = CON1', 'SRCF=CON2 if SRCF=<> and FA = CON1', NULL, NULL, 'IfFACon1AndSFBlankSetSFToCon2', NULL, 'Please enter field to check against', '', 'Please enter the value of field A', 'Please enter value to set source field to if blank', 1, 'This macro will update the current field with CON2 if the current field is blank but only if the specified field (field A) matches the value specified in CON1.\r\n\r\nThis macro never generates an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('109', 1, 'Update SRCF to CON2 when SRCF = CON1 else clear SRCF.', 'ifSFMatchCon1ThenCon2ElseClear', NULL, NULL, 'ifSFMatchCon1ThenCon2ElseClear', NULL, '', '', 'Please enter value to match for SF', 'Please enter value to update SF to', 1, 'This macro will update the current field with CON2 if the current field = CON1 but will clear the current field if the current field <> CON1.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('112', 1, 'String to Date', 'stringToDate', NULL, NULL, 'stringToDate', NULL, '', '', 'Please enter the inbound string\'s date format', 'Please enter the outbound string\'s date format', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('113', 1, 'Check - Zip Code', 'ZipCodeCheck', NULL, NULL, 'ZipCodeCheck', NULL, '', '', 'Optional - Please enter a default (e.g. 00000) for invalid zip codes (alphanumeric)', '', 1, 'This macro performs the following steps:\r\n- remove dashes from values\r\n- zip code length over length of 5 digits will be truncated to 5.\r\n- Optional\r\nIf a value is entered for the question \'Please enter a default for invalid zip codes (optional)\', \r\na default value will be added to all invalid (alphanumeric) zip codes. \r\nFor example, if a default value of 99999 is entered, \r\nabcde will be default to 99999\r\n- Optional\r\nIf \'Y\' is entered for the question \'Please enter Y if you would like to prepend 0(s) to zip codes that are 1-4 characters in length\', \r\nzip codes that are 1-4 characters in length will be prepended with 0(s) to make the zip code 5 characters long.\r\nFor example, zip code value of 345 will become 00345.\r\n\r\nThis macro will generate an error when alphanumeric values are found.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('115', 1, 'Check - If SF is blank and FA is specified value\"\"', 'Check - If SF is blank and FA is specified value\"\"', NULL, NULL, 'IfFieldACon1andSFBlankInsertError', NULL, 'Please enter field to match value to', '', 'Please enter value to be checked in FA', '', 1, 'This macro will check FA for a specified value (CON1). If there is a match AND the SRCF is blank, log an error.\r\n\r\nThis macro is typically used in family planning to check if the IFNOMETHOD field is populated when the contra metho field = NO METHOD.\r\n\r\nThis macro will generate an error if the check condition is met. Pass/clear and reject record/file logic will be activated if SRCF is required.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('128', 1, 'Append String with Value if Length matches', 'appendCon2IfCon1Length', NULL, NULL, 'appendCon2IfCon1Length', NULL, '', '', 'Please enter length of string', 'Please enter value to append', 1, 'These macro appends a string to a field value that matches the length of the string specified.    For example, we would like to append \' 00:00:00\' to any string that is 10 characters long in column 1.    We would enter 1 for \'Please enter column to append to\', 10 for \'Please enter length of string\' and \' 00:00:00\' for \'Please enter value to append\'.    An example is \'2019-02-28\', the result will be \'2019-02-28 00:00:00\'');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('129', 1, 'Apply CW to List', 'applyCWTranslatedList', NULL, NULL, 'applyCWTranslatedList', NULL, ' ', ' ', 'Please enter crosswalk Id', 'Enter Y to remove duplicaes; Enter N to keep duplictes.', 1, 'This macro applies a crosswalk to a column where the values are in a comma delimited list.   An example is translating a column 1\'s race valises into system Ids and store the translated values in column 2.    We would enter 1 for \'Please enter column with list\' and 2 for \'Please enter column to put translated list\'.  \'Please enter crosswalk Id\' will be the crosswalk Id assigned to races from the crosswalks table.    An example is column 1 with field \'White,Black\' , after allying this macro, column 2 will read 1,2    ');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('131', 1, 'If Source Field is empty set Src Field to value of another field', 'If SF is empty, copy FA to SF', NULL, NULL, 'IfSFBlankSetToFA', NULL, 'Please enter field to update empty source vlaues to', '', '', '', 1, 'This macro will copy the value found in FA to the SRCF if the SRCF is emplty.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('146', 1, 'Conditional: Compare Two Non-Blank Fields and Insert Errror when criteria is not met', 'CompareTwoFieldsAndError', NULL, NULL, 'CompareTwoFieldsAndError', NULL, 'Pleae enter field to compare source field to', NULL, 'Please enter how to compare - 1 (>), 2 (>=) , 3 (<), 4 (<=)', ' ', 0, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('147', 1, 'If SF Length is not Con 1 Replace With Con 2', 'IfLengthNotCon1ReplaceWithCon2', NULL, NULL, 'IfLengthNotCon1ReplaceWithCon2', NULL, '', '', 'Please enter length you wish field to be', 'Please enter value to replacement value', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('148', 1, 'If SRCF is not equal to CON1, clear SRCF', 'IF SRCF <> CON1, then SRCF = NULL', NULL, NULL, 'ifSFNotCon1ThenClear', NULL, '', '', 'Please enter value to match', '', 1, 'This macro will check for the CON1 value in the SRCF. If not found, the SRCF will be cleared.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('150', 1, 'If field is not blank insert error', 'ifNotBlankError', NULL, NULL, 'ifNotBlankError', NULL, '', NULL, '', NULL, 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('152', 0, 'Check - Insert error for transactions that is not part of visit set', 'errorNonYearMonthTransactions', NULL, NULL, 'errorNonYearMonthTransactions', NULL, NULL, NULL, NULL, '', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('156', 1, 'stripCharsFromStartOrEnd', 'stripCharsFromStartOrEnd', NULL, NULL, 'stripCharsFromStartOrEnd', NULL, '', '', 'Please enter number of characters to strip', 'Please enter 1 to strip from beginning, 2 for strip from end', 1, 'This macro will strip leading or trailing characters (any characters found) from the value stored in SF.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('160', 1, 'If value not in List set to Con2', 'ifValueNotInListValuesSetToCon2', 0, NULL, 'ifValueNotInListValuesSetToCon2', NULL, '', '', 'Please enter crosswalk Id', 'Please enter value to update to', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('161', 1, 'If SF Starts With Con1 Update To Con2', 'ifStartsWithCon1UpdateToCon2', NULL, NULL, 'ifStartsWithCon1UpdateToCon2', NULL, '', '', 'Please enter starting characters to check', 'Please enter replacement value', 1, 'This macro will check to see if the value specified in CON1 is found at the start of the value in SRCF and if true, replace SRCF with CON2.\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('165', 1, 'Check - Alpha Numeric', 'AlphaNumericCheck', NULL, NULL, 'AlphaNumericCheck', NULL, '', '', '', '', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('166', 1, 'Check - Future Date', 'rejectFutureDate', NULL, NULL, 'futureDateCheck', NULL, '', '', '', '', 1, '');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('167', 1, 'If value is not numeric replace with Con1', 'If SRCF <> NUM, SRCF = CON1', NULL, NULL, 'ifNotNumericSetToCon1', NULL, '', '', 'Please enter replacement value', '', 1, 'This macro will check to see if the value in the SRCF is numeric and if not, will insert CON1 value into the SRCF\r\n\r\nThis macro will never generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('169', 1, 'Perform arithmetic operation on SRCF and FA with results in SRCF', 'SRCF = SRCF (+,-,*,/) FA', NULL, NULL, 'ArithmeticConstant', NULL, 'Please enter the constant value', '', 'How many decimal places. (Defaults to 0 if left blank)', 'Please enter arithmetic operation ( + - / or *)', 0, 'This macro uses the specified arithmetic operator in CON2 and the value specified in FA to update the value stored in SRCF.\r\n\r\nSRCF = SRCF (+,-,*,/) FA\r\n\r\nIf the source field does not contain blank or a numeric value, the macro will generate an error.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('172', 1, 'Check - List Length', 'CheckListLengthIfGTError', NULL, NULL, 'CheckListLengthIfGTError', NULL, '', NULL, 'Please enter number for the expected elements in the list', '', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('173', 1, 'If SRCF, FA AND FB all blank, error', 'IfFieldsBlankThenError', NULL, NULL, 'IfFieldsBlankThenError', NULL, 'Please enter field number in additional to SF to check ', 'Please enter field number in additional to SF to check ', '', '', 0, 'This macro will check three firleds (SRCF, FA, FB) and if all three are blank, log an error.\r\n\r\n');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('174', 1, 'Populate Race Id and Individual Race Fields for CDS', 'PopulateFPRaceIdAndFields', NULL, NULL, 'PopulateFPRaceIdAndFields', NULL, '', '', 'Please enter value to populate individual race fields with', '', 1, 'This macro manages how multiple race fields and the individual race fiueld is populated.\r\n\r\nFirst, the macro looks at individual race fields are in use.  If not, it will use the single race Id to populate individual race fields.\r\n\r\nFor example - \r\n1. If individual race fields are in use, it will populate the single race field (FA) after assessint the contents of the individual race fields.\r\n\r\nIndividual race fields include.....\r\n\r\n2. If it finds that individual race fields are not in use, it will look at what is in the source field and populate the individual race fields.\r\nFor example, the source field value is \'1,2\'. This macro will set White - Y, Black - Y and single race field to 6 (more than one race)\r\nAnother example is source field value is \'1\'.  It will set White - Y and single race field (fieldA) to 1.\r\n');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('177', 1, 'Keep Top Ranked Value', 'KeepTopRanked', NULL, NULL, 'KeepTopRanked', NULL, '', '', 'Please enter crosswalk with rank list', NULL, 1, 'This macro takes a list of values and compare with a crosswalk and keep only top matching value');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('178', 1, 'Remove Duplicate Value from List', 'Remove Dup Values from List', NULL, NULL, 'removeDupFromList', NULL, '', '', '', '', 1, 'This macro will remove duplicate values from the source field.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('179', 1, 'Merge Records', 'Merge Records', NULL, NULL, 'mergeTransactions', NULL, 'Please enter the field number for site ID', 'Please enter the field number for Client Identifier (MRN)', 'Please enter the field number for visit date', 'Please enter the field number of the field to be merged (typically med svcs)', 1, 'This macro is typically used for family planning where the customer submits one record for each ICD/CPT code in a visit, resulting in multiple records in the submission for a single patient visit. This macro will merge records with the same site ID, patient ID and visit date. Medical services from all matched records will be stored in the first record and only the first matched record will be saved. \r\n\r\nThis macro does not generate errors.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('180', 1, 'Prepend String with Value if Length matches', 'prependCon2IfCon1Length', NULL, NULL, 'prependCon2IfCon1Length', NULL, '', '', 'Please enter length of string', 'Please enter value to prepend', 1, 'This macro prepends a string to a field value that matches the length of the string specified.    For example, we would like to append \'0\' to any string that is 4 characters long in column 1.    We would enter 1 for \'Please enter column to prepend to\', 4 for \'Please enter length of string\' and \'0\' for \'Please enter value to prepend\'.    An example is \'2155\', the result will be \'02155\' This is most commonly used to add back the 0 in a  zip code ');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('181', 1, 'Merge Values for Column', 'mergeValues', NULL, NULL, 'mergeValues', NULL, 'Please enter the field number (fieldNo) for Site Id (just #, no F)', 'Please enter the field number for Client Identifier', 'Please enter the field number for visit date', 'Please enter the field number for the column to merge', 1, 'This macro merges records for specified column (usually icd codes) and make  Site/Client Identifier/ Visit Date combination have the same value. For example, if Patient A, Site 123, Visit Date 1/1/2020 has two entries, one with ICD codes Z11.3,Z11.4,Z32.02, 2nd entry with ICD codes N76.0,Z30.011,Z01.419,Z30.49,Z31.9,N39.0, both entries will have ICD Codes Z11.3,Z11.4,Z32.02, N76.0,Z30.011,Z01.419,Z30.49,Z31.9,N39.0 after running this macro.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('183', 1, 'Date - mmddyyyy to yyyymmdd', 'Convert Date mmddyyyy to yyyymmdd', NULL, NULL, 'datemmddyyyyToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in mmddyyyy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('184', 1, 'Date - dd-mon-yy to yyyymmdd', 'Convert Date dd-Mon-YY to yyyymmdd', NULL, NULL, 'dateddmonyyWithDashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in dd-mon-yy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('185', 1, 'Date - mm/dd/yyyy to yyyymmdd', 'Convert Date mm/dd/yyyy to yyyymmdd', NULL, NULL, 'datemmddyyyyWithSlashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in mm/dd/yyyy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('186', 1, 'Date - m/dd/yyyy to yyyymmdd', 'Convert Date m/dd/yyyy to yyyymmdd', NULL, NULL, 'datemddyyyyWithSlashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in m/dd/yyyy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('187', 1, 'Date - mm/d/yyyy to yyyymmdd', 'Convert Date mm/d/yyyy to yyyymmdd', NULL, NULL, 'datemmdyyyyWithSlashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in mm/d/yyyy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('188', 1, 'Date - m/d/yyyy to yyyymmdd', 'Convert Date m/d/yyyy to yyyymmdd', NULL, NULL, 'datemdyyyyWithSlashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in m/d/yyyy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('189', 1, 'Date - yyyy-mm-dd to yyyymmdd', 'Convert Date yyyy-mm-dd to yyyymmdd', NULL, NULL, 'dateyyyymmddWithDashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in yyyy-mm-dd format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('190', 1, 'Date - mddyyyy (single digit month) to yyyymmdd', 'Convert Date mddyyyy to yyyymmdd', NULL, NULL, 'datemddyyyyToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in mddyyyy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('191', 1, 'Date - mm/dd/yy (two digit year) to yyyymmdd', 'Convert Date mm/dd/yy to yyyymmdd', NULL, NULL, 'datemmddyyWithSlashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in mm/dd/yy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('192', 1, 'Date - m/d/yy to yyyymmdd', 'Convert Date m/d/yy to yyyymmdd', NULL, NULL, 'datedmyyWithSlashesToyyyymmdd', NULL, '', '', '', '', 1, 'This macro will convert a date value in m/d/yy format to yyyymmdd format. If the date format is invalid, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('193', 1, 'Date - Insert error for invalid dates', 'Error Invalid Date', NULL, NULL, 'CheckInvalidDateAndError', NULL, '', '', 'Please enter current date format - i.e. %Y%m%d for yyyymmdd', '', 1, 'This macro checks the field for a valid date.  User will enter in the format of the date using corresponding MySQL format.\r\nFor example,  dates in yyyymmdd format will be %Y%m%d\r\n\r\nBelow are the acceptable formats - \r\n%c - (m) Numeric month name (0 to 12)\r\n%d - (dd) Day of the month as a numeric value (01 to 31)\r\n%e - (d) Day of the month as a numeric value (0 to 31)\r\n%M - (month) Month name in full (January to December)\r\n%m - (mon) Month name as a numeric value (00 to 12)\r\n%Y - (yyyy) Year as a numeric, 4-digit value\r\n%y - (yy) Year as a numeric, 2-digit value');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('194', 1, 'Numeric Range', 'Numeric Range', NULL, NULL, 'NumericRange', NULL, '', 'Please enter start range', 'Please enter end range', '', 0, 'This macro will verify that a field is numeric and that the value falls within the specified numeric range. If the field is not numeric or does not fall within the specified range, an error will be logged. Pass/clear logic and reject record/reject file logic will be activated when an error is logged.');
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('195', 1, 'Apply CW to List without Tracking Dropped Values', 'Apply CW to List without Tracking Dropped Values', NULL, NULL, 'applyCWTranslatedListNoTrackDroppedValues', NULL, NULL, NULL, 'Please enter crosswalk Id', 'Enter Y for distinct value only, Enter N for all values', 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('196', 1, 'Check - Regular Expression', 'regExCheck', NULL, NULL, 'regExCheck', NULL, NULL, NULL, 'Please enter the regular expression', NULL, 1, NULL);
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Ref_Number`, `Date_Display`, `Formula`, `Invalid_When`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`, `macroDesc`) VALUES ('197', 1, 'Compare Two Fields and Update SF to Con2', 'Compare Two Fields and Update SF to Con2', NULL, NULL, 'CompareTwoFieldsAndUpdateSF', NULL, 'Please enter field to compare source field to', ' ', 'Please enter comparison (< , <=, =, >, >=, !=)', 'Please enter value to update SF to', 1, NULL);

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `AlphaNumericCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @whereClause  = concat("  (",srcField," REGEXP '^[a-zA-Z0-9]*$' != 1 or ",srcField," REGEXP '^[a-zA-Z0-9]*$' is null)
            and ",srcField," is not null and  length(",srcField,") > 0 and ");
            
set @whereString = concat(@whereClause, "  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

			set @stmt = concat("update ",@translatedTable," set forCW = 'MACRO_ERROR' where ",@whereString);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendCon2IfCon1Length`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'appendCon2IfCon1Length Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 = 0) then
	set @whereClause = concat(" or ",srcField," is null");
end if;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = concat_ws('',",srcField,", '", con2, "') where (length(",srcField,") = ",con1,@whereClause,") and ",
"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendPrependString`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** 
FA - Prepend string
FB - prepend Y/N to Blanks
Con1 = Append String
Con2 - append Y/N to blanks
**/
-- we remove the first F
	set @prependString = substring(fieldA, 2, length(fieldA) -1);
    set @prependBlanks =  substring(fieldB, 2, 1);
    
    set @appendString = con1;
    set @appendBlanks =  con2;
    
    
			set @stmt = concat("update ", @translatedTable," set forcw = case when ",srcField," is null or length(",srcField,") = 0 then  'blank' else 'notblank' end;");

            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
            
    
    
	set @wherePrependString = concat(" and ",srcField, " is not null and length(",srcField,") > 0");
	-- first we prepend
	if (@prependBlanks = 'Y') then
		begin
			set @wherePrependString = '';
        end;
    end if;
    
			set @stmt = concat("update ", @translatedTable," set ",srcField,
			" = case when ",srcField," is null then '",@prependString,"' else concat('", @prependString, "', ", srcField, ") end where ",
			"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")",@wherePrependString,";");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


-- then we append
	set @whereAppendString = concat(" and ",srcField, " is not null and length(",srcField,") > 0 and forcw != 'blank' ");
		-- first we prepend
		if (@appendBlanks = 'Y') then
			begin
				set @whereAppendString = '';
			end;
		end if;

		set @stmt = concat("update ", @translatedTable," set ",srcField,
			" = case when ",srcField," is null then '",@appendString,"' else concat(",srcField,", '",@appendString,"') end where ",
			"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")",@whereAppendString,";");
         
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

		
			set @stmt = concat("update ", @translatedTable," set forcw = null;");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
		set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end if;
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
    if (passClear = 2) then

		set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is null and length(invalue) > 0;
		");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
	end if;

	set @stmt = concat("
		insert into transaction",@colText,"macrokeptvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
		select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue, concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is not null;
	");
 
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedListNoTrackDroppedValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	
    
     
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
	
    
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
		set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
        
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	
    end if;
  
  
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	
    
       
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ArithmeticConstant`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		-- multipler
		set fieldA = REPLACE(fieldA,'F','');
       
       if(fieldA is null or fieldA = '') then 
			BEGIN
				set fieldA = 0;
			END;
		end if;
        
        -- con1 
        if(con1 is null or con1 = '') then 
			BEGIN
				set con1 = 0;
			END;
		end if;

        -- check to see if con1 is numeric
      if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 or   fieldA REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant Con1 - ",con1,"  or FA - ",fieldA," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
        -- division by 0
      if con2 = '/'  and  fieldA = '0' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant Divide (con2) by 0 (con1) error.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
      -- for con2 we only accept * +  / - 
       -- check to see if con1 is numeric
      if con2 != '/'  and  con2 != '-'  and con2!='*' and con2 != '+' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant con2 - ", con2," is not a valid arithmetic operation.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
		
        -- insert macro error if srcField is not numeric
        
        
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where ",srcField,"  REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0
        and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		

		 set @stmt = concat("update ",@translatedTable, " set ",srcField," = ROUND((",srcField," ",con2," ",fieldA,"),",con1,") where 
         forcw is null and 
         configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")
		 and ",con1 ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 1  and ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 1 ;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckInvalidDateAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, "  where 
					(str_to_date(",srcField,",'",con1,"') is null or str_to_date(",srcField,",'",con1,"') = '0000-00-00'
                    or right(str_to_date(",srcField,",'",con1,"'), 2) = '00' or left(str_to_date(",srcField,",'",con1,"'), 2) = '00' 
                    or substring(str_to_date(",srcField,",'",con1,"'), 6, 2) = '00' 
                    ) 
                    and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;
     


set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",con1,"') where (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
 

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and  (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckLengthAndReplace`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);

SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

      -- check to see if con1 is numeric
      if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CheckLengthAndReplace Con1 - ",con1,"  must be a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
		
        set @con1is0 = '';
        if (con1 = '0') then 
			set @con1is0 = concat(" or ", srcField," is null");
        end if;
        
      	
		set @stmt = concat("update ",@translatedTable, " set ",srcField," =  '", con2, "'",
		"   where (length(",srcField, ") = ",con1," ", @con1is0, ")  and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckListLengthIfGTError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

/** con1 must be numeric and greater than 1 **/

				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CheckListLengthIfGTError Macro - Con1 - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

	set @errorCode='52';

	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


	set @requiredField = true;
    set @stmt = concat("update ", @translatedTable, " set statusId = 14 where  LENGTH(",srcField,") - LENGTH(REPLACE( ",srcField,", ',', '')) + 1 > ",con1," and ", 
		@whereString);
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue, required, fieldLabel, stackTrace) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", @errorCode, 
    ", ",macroId,",",srcField,", ",@requiredField,", '",@fieldName,"', 'CheckListLengthIfGTError - list length is too long. Expecting ", con1,".'  from ", @translatedTable, " where  LENGTH(",srcField,") - LENGTH(REPLACE( ",srcField,", ',', '')) + 1 > ",con1," and ", 
    @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    
     
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `clearSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '' where 
        configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
Conditional: Compare Two Non-Blank Fields and Insert Error when criteria is not met
need to compare nulls and blanks, will treat null as blanks
**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndError con1 - ", con1," is not a valid comparison.'",", ",true);
                            
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- This macro need to handle blanks and nulls, we treat nulls as blanks
    
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 ",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = case when comparedResults = true then 'compared' else 'MACRO_ERROR' end ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
		/** we compare and update **/
      /** we compare all the fields that has null, we treat nulls as blanks **/
    
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select case when ",srcField, " is null then '' else ", srcField," end " , con1, " case when ",fieldA, " is null then '' else ", fieldA," end comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set forCW = case when comparedResults then '' else 'MACRO_ERROR' end ");
	 
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;

	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndUpdateSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
and will update to con2

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>'then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndUpdateSF con1 - ", con1," is not a valid comparison.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
	
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = 'compared', ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update 
     we treat nulls as blanks
     **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select case when ",srcField, " is null then '' else ",srcField, " end " , con1, 
        " case when ",fieldA, " is null then '' else ",fieldA, " end ",
        " comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end ");
	
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `concatFieldToList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @fields = concat('F', replace(replace(con2, ' ', ''), ',', ',F'));
set @sql = concat("concat_ws('",con1,"', " , @fields , ")");


		set @stmt = concat("update " ,@translatedTable,  " set ", srcField, " = ", @sql , 
		" where configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `copyField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = ", fieldB, 
    " where configId = ",configId," and ", @batchIdColumn, " = ",batchId," and statusId not in (",@finalStatusIds,");");	
    
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `createTempErrorTable`(in inBatchId int)
proc_main:begin


SET @stmt = CONCAT("drop TABLE if exists transactionoutdetailauditerrorsforinbound_",inBatchId);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
CREATE TABLE transactionoutdetailauditerrorsforinbound_",inBatchId," (
  id int(11) NOT NULL AUTO_INCREMENT,
  batchDownloadId int(11) NOT NULL,
  configId int(11) NOT NULL,
  transactionOutRecordsId int(11) NOT NULL,
  fieldNo int(11) NOT NULL,
  fieldName varchar(45) DEFAULT NULL,
  errorId int(11) NOT NULL,
  errorDetails varchar(200) DEFAULT NULL COMMENT 'This field is used to update cw name, validation type name, macro name',
  errorData text,
  reportField1Data varchar(45) DEFAULT NULL,
  reportField2Data varchar(45) DEFAULT NULL,
  reportField3Data varchar(45) DEFAULT NULL,
  reportField4Data varchar(45) DEFAULT NULL,
  transactionOutErrorId int(11) DEFAULT '0',
  required bit(1) default null,
  PRIMARY KEY (id),
  KEY ttoauditKey",inBatchId,"Error_idx (batchDownloadId)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
");

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateddmonyyWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%d-%b-%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 3), 1) != '-' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        


		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		if (@goodIds is not null) then

		begin


			/** fix two digit years **/
			select year(curdate()) into @currYear;

			set @stmt = concat("update ",@translatedTable, " set forcw =  DATE_ADD(forcw, INTERVAL -100 Year) where id in (",@goodIds,") 
			and year(forcw) > ",@currYear,"");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
		
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datedmyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%e/%c/%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        


		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		if (@goodIds is not null) then

		begin

			/** fix two digit years **/
			select year(curdate()) into @currYear;

			set @stmt = concat("update ",@translatedTable, " set forcw =  DATE_ADD(forcw, INTERVAL -100 Year) where id in (",@goodIds,") 
			and year(forcw) > ",@currYear,"");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
		
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%Y-%m-%d');
        set @outboundDateFormat = concat('%Y%m%d');

                set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where length(",srcField,") !=7 and length(",srcField,") !=8
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				/**
					manually add slashes to make it mysql date format since mysql has trouble understanding dates without date separator
					if 7 digits we insert one-two-four
                    if 8 digits we insert two-two-four
                
                **/
                
				set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '',  '-0', left(",srcField,", 1), '-', substring(",srcField,", 2,2)) 
                where length(",srcField,") =7 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                
                set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '-',left(",srcField,", 2) , '-', substring(",srcField,", 2,2))
                where length(",srcField,") =8 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				--  check inbound date formats and log
				set @errorIds = "";
				set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(forcw, '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;

		
		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0 and forcw != 'MACRO_ERROR' and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%c/%d/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%c/%e/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%c/%e/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';



set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%d/%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;

		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		if (@goodIds is not null) then

		begin

		/** fix two digit years **/
			select year(curdate()) into @currYear;

			set @stmt = concat("update ",@translatedTable, " set forcw =  DATE_ADD(forcw, INTERVAL -100 Year) where id in (",@goodIds,") 
			and year(forcw) > ",@currYear,"");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt; 
        
        
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%m",con2,"%d",con2,"%Y");
set @outboundDateFormat = concat("%Y",con1,"%m",con1,"%d");



--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,",length(con1),") != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
       PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then
begin
-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%m/%d/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%m/%d/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';



set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%e/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%Y",con1,"%m",con1,"%d");
set @outboundDateFormat = concat("%m",con2,"%d",con2,"%Y");


--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,",length(con1),") != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
       PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then
begin
-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%Y-%m-%d') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%Y-%m-%d') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';


set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `errorNonYearMonthTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin



call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereClause = concat(" and  configId = ",configId," and ", @batchIdColumn," = ",batchId," and statusId not in (",@finalStatusIds ,") ");

set @totalCount1 = 0;
set @yearMonthToUse1 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 0, 1 into @totalCount1, @yearMonthToUse1
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

set @totalCount2 = 0;
set @yearMonthToUse2 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 1, 1 into @totalCount2, @yearMonthToUse2
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


set @stmt = concat("select fieldDesc from configurationformfields where configId = ",configId," 
and fieldNo = replace('",srcField,"', 'F', '') 
into @fieldLabel;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



if (@totalCount1 = @totalCount2) then
 
	BEGIN
			set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
			", fieldNo, errorId, macroId, stackTrace, required, fieldLabel, fieldValue) select ",batchId,", ",configId,", ",@translateCol, ", replace('",srcField,"', 'F', ''), ", 8, 
			", ",macroId, ", 'Macro rejectNonYearMonthTransactions - Could not determine which date to use:  "  "Year Month - ",@yearMonthToUse1, " and ",@yearMonthToUse2," have the same numbers of transactions - ",@totalCount1, "'",
            ", true, '",@fieldLabel,"', ",srcField," from ", @translatedTable, " where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        set @stmt = concat("update ",@translatedTable, " set statusId = 14 where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        
	END;
end if;
			if (@totalCount1 > @totalCount2) then
				BEGIN
                
					
					set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
					", fieldNo, errorId, macroId, stacktrace, required,fieldLabel, fieldValue) select ",batchId,", ",configId,", ", @translateCol, ", replace('",srcField,"', 'F', ''), 60,",
                    macroId,", concat('Year and month of ', DATE_FORMAT(",srcField,",'%Y%m'), ' for ',",srcField,", ' does not match year and month ',",@yearMonthToUse1,",' used for processing.')
                    , true, '",@fieldLabel,"', ",srcField,"  from ", @translatedTable, " where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
					
                    PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                    
                    set @stmt = concat("update ",@translatedTable, " set statusId = 14 where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
                    
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                
                END;
		end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `futureDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)
 or (curdate() >= ", srcField , " = 0))
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then
	begin
		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getConfigToFromFieldNo`(in cInId int, in cOutId int)
proc_main:begin

drop TEMPORARY TABLE if exists fieldAndNos;

CREATE TEMPORARY TABLE fieldAndNos as (select id, cOutId as configIdOut, cInId as configIdIn, 
fieldNo as fieldNoIn, fieldNo as fieldNoOut, saveToTableName, saveToTableCol from configurationFormFields where configId = cOutId order by fieldNoOut);

update fieldAndNos set fieldNoIn = 0;

BEGIN
 
    DECLARE v_finished INTEGER DEFAULT 0;
	DECLARE v_saveToTableName varchar(100) DEFAULT "";
	DECLARE v_saveToTableCol varchar(100) DEFAULT "";
	DECLARE v_fieldNoIn int DEFAULT 0;
	DECLARE v_fieldNoOut int DEFAULT 0;
	DECLARE v_newFieldNo int DEFAULT 0;
	DECLARE v_id int default 0;

 
    
    DEClARE fieldNo_cursor CURSOR FOR 
        SELECT id, fieldNoIn, fieldNoOut, saveToTableName, saveToTableCol from fieldAndNos order by fieldNoOut;

    
    DECLARE CONTINUE HANDLER 
        FOR NOT FOUND SET v_finished = 1;
	
    OPEN fieldNo_cursor;
	
	get_fieldNo: LOOP
		
		
        
		FETCH fieldNo_cursor INTO v_id, v_fieldNoIn, v_fieldNoOut, v_saveToTableName, v_saveToTableCol;
 
        IF v_finished = 1 THEN 
            LEAVE get_fieldNo;
        END IF;
	
	
        
	if  (v_id > 1) then
		set v_newFieldNo = 0;
		
		select count(fieldNo) into v_newFieldNo from configurationFormFields where configId = cInId 
		and saveToTableName = v_saveToTableName and saveToTableCol = v_saveToTableCol order by fieldNo limit 1;
		
		if (v_newFieldNo > 0) then
			select fieldNo into v_newFieldNo from configurationFormFields where configId = cInId 
			and saveToTableName = v_saveToTableName and saveToTableCol = v_saveToTableCol order by fieldNo limit 1;
			update fieldAndNos set fieldNoIn = v_newFieldNo where id = v_id;
		end if; 
		
		
		
	end if;
	
    END LOOP get_fieldNo;
 
    CLOSE fieldNo_cursor;

	
END;

select * from fieldAndNos order by fieldNoOut;
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getFinalStatusIds`()
proc_main:begin

set @finalStatusIds =  '11,12,13,16,18,20,40';


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getJSONForConfig`(in inConfigId int, 
in inBatchDLId int, in inFilePathAndName varchar(500), in inJSONWrapperElement varchar(55))
proc_main:begin

SET @@group_concat_max_len = 999999999;


set @whereClause = '';

set @cleanStmt = concat('delete from transactionoutjsontable_',inBatchDLId,' where configId = ', inConfigId);

PREPARE stmt from @cleanStmt;
EXECUTE stmt;

select group_concat(concat('''"', fieldlabel, '":'', ', concat('case when trim(F', fieldNo), ') is null then ''"",'' else concat(''"'', trim(replace(replace(replace(F',fieldNo, ',"\r",""),"\n",""),"\"""," ")), ''",'') end')) 
from configurationformfields where configId = inConfigId and usefield = 1 order by fieldNo into @selectValues;

set @stmt = concat("insert into transactionoutjsontable_",inBatchDLId," (batchDownloadId, configId, transactionOutRecordsId, jsonString) 
select batchId, configId, transactionOutRecordsId, replace(replace(concat('{', ",@selectValues,", '}'), ',},', '},'), ',}', '},')  
from transactiontranslatedout_",inBatchDLId," where configId = ", inConfigId, @whereClause);
PREPARE stmt from @stmt;
EXECUTE stmt;

if(inJSONWrapperElement != '') then
	
	set @stmt = concat("update transactionoutjsontable_",inBatchDLId," join (
	select min(id) theId from transactionoutjsontable_",inBatchDLId," where configId = ", inConfigId, @whereClause, ") getId
	on transactionoutjsontable_",inBatchDLId,".id = getId.theId
	set jsonString = concat('{\"",inJSONWrapperElement,"\":[' , jsonString) 
	where configId = ", inConfigId, @whereClause, "");

end if;

PREPARE stmt from @stmt;
EXECUTE stmt;

if(inJSONWrapperElement != '') then

	set @stmt = concat("update transactionoutjsontable_",inBatchDLId," join (
	select max(id) theId from transactionoutjsontable_",inBatchDLId," where configId = ", inConfigId, @whereClause, ") getId
	on transactionoutjsontable_",inBatchDLId,".id = getId.theId
	set jsonString = concat(replace(jsonString, '},','}'), ']}') 
	where configId = ", inConfigId, @whereClause, "");

end if;

PREPARE stmt from @stmt;
EXECUTE stmt;


set @stmt = concat("select jsonString from transactionoutjsontable_",inBatchDLId," where configId = ", inConfigId, @whereClause, 
" order by Id INTO OUTFILE '", inFilePathAndName, "';");

PREPARE stmt from @stmt;
EXECUTE stmt;


PREPARE stmt from @cleanStmt;
EXECUTE stmt;

 
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFACon1AndSFBlankSetSFToCon2`(in configId int,
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255),
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2, "'
  where " ,fieldA, " = '",con1, "' and length(",srcField,") = 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldACon1andSFBlankInsertError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable,
		@translateCol
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

		set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		set @stmt = concat("select fieldDesc from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') into @fieldDesc;");
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
		", fieldNo, errorId, macroId, fieldValue, required, stackTrace, fieldLabel) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", 58, 
	   ", ",macroId,",case when ",srcField," is null then '' else ",srcField," end, true, 'A value is required if \"",@fieldDesc,"\" is value \"",con1, "\"', '",@fieldDesc,"' from ", @translatedTable, 
       " where ",fieldA,"  = '",con1,"' and (",srcField," is null 
       or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and ", 
		@whereString);
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
		set @stmt = concat("update ", @translatedTable, " set statusId = 14 
        where  ",fieldA,"  = '",con1,"' and (",srcField," is null 
        or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and ", 
		@whereString);
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldsBlankThenError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @errorCode='51';

	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


	set @sqlConstraintS = concat(" (",srcField," is null or length(",srcField,") = 0)");
    set @sqlConstraintA = "";
    set @sqlConstraintB = "";
    set @fieldAName = '';
    set @fieldBName = '';
    
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    if (fieldA != 'F') then 
		 set @sqlConstraintA = concat(" and  (",fieldA," is null or length(",fieldA,") = 0)");
         set @stmt = concat("select concat(', ', fieldDesc) into @fieldAName from configurationformfields where configId = ",configId," and fieldNo = replace('",fieldA,"', 'F', '') limit 1;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
    end if;
    
    if (fieldB != 'F') then 
		 set @sqlConstraintB = concat(" and  (",fieldB," is null or length(",fieldB,") = 0)");
         set @stmt = concat("select concat(', ', fieldDesc) into @fieldBName from configurationformfields where configId = ",configId," and fieldNo = replace('",fieldB,"', 'F', '') limit 1;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
    end if;
    
    set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue, required, fieldLabel, stackTrace) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", @errorCode, 
    ", ",macroId,",'', true, '",@fieldName,"', 'IfFieldsBlankThenError - Field(s) ",@fieldName, @fieldAName, @fieldBName," cannot all be blank.'  
    from ", @translatedTable, "  where",@sqlConstraintS,@sqlConstraintA, @sqlConstraintB, "  and ", 
    @whereString);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@translatedTable," set statusId = 14  where",@sqlConstraintS,@sqlConstraintA, @sqlConstraintB, "  and ", 
    @whereString);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfLengthNotCon1ReplaceWithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'IfLengthNotCon1ReplaceWithCon2 Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 != 0) then
	set @whereClause = concat(" or ", srcField," is null");
end if;

set @stmt = concat(
"update ", @translatedTable," set ",srcField, " = '", con2,"' where (length(",srcField,") != ",con1, @whereClause, ") and 
configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotBlankError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

    set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where ",
    srcField," is not null and length(",srcField,") > 0 ",
    " and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotNumericSetToCon1`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @whereclause = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");

	set @dropTable = "batchuploaddroppedvalues";
	set @colDirection = "in";

	if (foroutboundProcessing) then

		set @dropTable = "batchdownloaddroppedvalues";
		set @colDirection = "out";
		
	end if;

	-- track values being replaced
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

	set @stmt1 = concat("
    insert into ",@dropTable,"
    (transaction",@colDirection,"RecordsId, fieldNo, ",@batchIdType ,", configId, fieldName, fieldValue) 
     select transaction",@colDirection,"RecordsId, replace('",srcField,"', 'F', ''), ",@batchIdType,", configId, '",@fieldName,"', ",srcField,"
     from ",@translatedTable, " where  ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 
     and ",srcField," is not null and length(",srcField,") > 0 ");
		
	set @stmt = concat(@stmt1, @whereclause, ";");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    

	set @stmt1 = concat("update ",@translatedTable, " set ",srcField, " = '", con1 , "' where  
    ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 
    and ",srcField," is not null and length(",srcField,") > 0 ");
	
    set @stmt = concat(@stmt1, @whereclause, ";");
     
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfSFBlankSetToFA`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",srcField," = ",fieldA, " 
     where (length(",srcField, ") = 0 or ", srcField ," is null) and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") ");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfSFMatchCon1SetFAtoFB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",fieldA," = ",fieldB, " 
     where " ,srcField, " = '",con1, "' and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifSFMatchCon1ThenCon2ElseClear`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set ",srcField, " = case when ", srcField, " = '",con1,"' then '", con2 , "' else '' end",
		" where  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifSFNotCon1ThenClear`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField, " = '' ",
				" where  ",srcField," != '",con1,"' and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifStartsWithCon1UpdateToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",srcField, " = '", con2, "'    where left(",srcField,", ", length(con1), ") = '",con1,"' ",
				" and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    if (length(con1) = 0) then
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where (",srcField," is null or ",srcField," = '')
		and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt; 

end if;
    

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifValueNotInListValuesSetToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** cwId con1 must be numeric **/
if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ifValueNotInListValuesSetToCon2 Macro - Con1 - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;


set @leaveBlanks = "";


set @dropTable = "batchuploaddroppedvalues";
set @colDirection = "in";

if (foroutboundProcessing) then

	set @dropTable = "batchdownloaddroppedvalues";
	set @colDirection = "out";
    
end if;

	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

	set @stmt1 = concat("
    insert into ",@dropTable,"
    (transaction",@colDirection,"RecordsId, fieldNo, ",@batchIdType ,", configId, fieldName, fieldValue) 
     select transaction",@colDirection,"RecordsId, replace('",srcField,"', 'F', ''), ",@batchIdType,", configId, '",@fieldName,"', ",srcField,"
     from ",@translatedTable," where   ",srcField," is not null and length(",srcField,") != 0 and 
    ",srcField ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
    
	set @stmt = concat("update ",@translatedTable, " set ", srcField, " = '",con2,"' where   ",srcField," is not null and length(",srcField,") != 0 and 
    ",srcField ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
	
	PREPARE stmt1 from @stmt1;
	EXECUTE stmt1;
    DEALLOCATE PREPARE stmt1;
   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int, in isFieldRequired boolean)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN 
		set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, transactionId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 4 THEN
		
        set regEx = '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])';
	WHEN 5 THEN 
		set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
	WHEN 6 THEN
		set regEx = '^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&\'\(\)\*\+,;=.]+$';
     WHEN 7 THEN
        set regEx = '^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])';       
    ELSE
        BEGIN
        END;
	END 
	CASE;

IF (transactionId = 0) THEN
set @stmt = concat(
'insert into transactioninerrors_',batchUploadId,' (batchUploadId, transactionInRecordsId, fieldNo, required, fieldValue, errorid, configId,
validationTypeId) SELECT ', batchUploadId, ', transactionInRecordsId, ',fieldNo,',',isFieldRequired,concat(',F',fieldNo),',2, ',configId, ',' , vtType,'  
 FROM transactiontranslatedin_',batchUploadId,' WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNo, ') != 0
and length(trim(F', fieldNo, ')) != 0
and length(REPLACE(REPLACE(F', fieldNo,' , "\n", ""), "\r", "") != 0)  
and  configId = ', configId,' and statusId not in (11,12,13,16,20);'
);



BEGIN 
		PREPARE stmt from @stmt;
		EXECUTE stmt;
END; 
END IF;


END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrorsOutbound`(in vtType int, in fieldNo int,
in batchDownloadId int, in configId int, in transactionId int, in isFieldRequired boolean)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN 
		set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `stripPhoneCharsOutbound`(vtType, fieldNo, batchDownloadId, configId, transactionId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 4 THEN
		
         set regEx = '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])';
	WHEN 5 THEN 
		set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
	WHEN 6 THEN
		set regEx = '^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&\'\(\)\*\+,;=.]+$';
    WHEN 7 THEN
         set regEx = '^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])';    
    ELSE
        BEGIN
        END;
	END 
	CASE; 

IF (transactionId = 0) THEN
set @stmt = concat(
'insert into transactionouterrors_',batchDownloadId,' (batchDownloadId, transactionOutRecordsId, fieldNo, required, fieldValue, errorid, configId,
validationTypeId) SELECT ', batchDownloadId, ', transactionOutRecordsId, ',fieldNo,',',isFieldRequired,concat(',F',fieldNo),',2, ',configId, ',' , vtType,'  
 FROM transactiontranslatedout_',batchDownloadId,' WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNo, ') != 0
and length(trim(F', fieldNo, ')) != 0
and length(REPLACE(REPLACE(F', fieldNo,' , "\n", ""), "\r", "") != 0)  
and  configId = ', configId,' and statusId not in (11,12,13,16,18,20);'
);

BEGIN 
		PREPARE stmt from @stmt;
		EXECUTE stmt;
END; 
END IF;

IF (transactionId != 0) THEN

set @stmt= concat(
'insert into transactionouterrors_',batchDownloadId,' (batchDownloadId, transactionOutRecordsId, fieldNo, errorid, configId, 
validationTypeId) SELECT ', batchDownloadId, ', transactionOutRecordsId, ',fieldNo,',2, ', configId, ',', vtType,'  
 FROM transactiontranslatedout_',batchDownloadId,' WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,', "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionTargetId 
 = ', transactionId, ';'
);

BEGIN 
		PREPARE stmt from @stmt;
		EXECUTE stmt;


END; 
END IF;

 
END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `KeepTopRanked`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** make sure con1 is numeric **/
/** con1 must be numeric and greater than 1 **/

				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'KeepTopRanked Macro - Crosswalk Id - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;


set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

	set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)) value, ",@fcol,"
    FROM ",@translatedTable ," t CROSS JOIN (
    SELECT a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <= ",@maxListLength,") a
   ,(select id N from ref_numbers where id <= ",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
    -- we delete the single values from top rank look up 
     set @stmt = concat("
		delete t1 from  ", @listTable," t1 join (
	   select t1.",@translateCol," from ", @listTable," t1 join (
	   select count(",@translateCol,") recordCount, ",@translateCol,"
	   from ", @listTable," group by ",@translateCol,"
	   order by recordCount) t2 on 
	   t1.",@translateCol," = t2.",@translateCol,"
	   where recordCount = 1) t2 
	   on t1.",@translateCol," = t2.",@translateCol,";");
   
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
     
	set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

	set @selDistinct = ' distinct ';
    
    set @stmt = concat("update ",@translatedTable," join  (
	SELECT tt.",@translateCol," as matchId,  invalue label
	FROM ",@listTable," tt
	INNER JOIN
	(SELECT ",@translateCol,", min(CONVERT(translatedValue,UNSIGNED INTEGER) ) AS topRanked
	FROM ",@listTable," 
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
	GROUP BY ",@translateCol," order by ",@translateCol,") groupedtt 
	ON tt.",@translateCol," = groupedtt.",@translateCol," 
	AND tt.translatedValue = groupedtt.topRanked
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
    order by tt.",@translateCol,"
   ) cwmatch on ",@translateCol," = matchid set ",srcField," = label 
   where label is not null
   ");
	
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    -- track the topranked value
    
    set @stmt = concat("
	update ",@listTable," t1 join  (
	SELECT tt.id as matchId,  invalue label
	FROM ",@listTable," tt
	INNER JOIN
	(SELECT ",@translateCol,", min(CONVERT(translatedValue,UNSIGNED INTEGER) ) AS topRanked
	FROM ",@listTable," 
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
	GROUP BY ",@translateCol," order by ",@translateCol,") groupedtt 
	ON tt.",@translateCol," = groupedtt.",@translateCol," 
	AND tt.translatedValue = groupedtt.topRanked
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
    order by tt.",@translateCol,"
   ) cwmatch on t1.id = cwmatch.matchId set translateIdToKeep = 1
   where label is not null;");
    
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    /** track dropped values **/
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
	
    set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat('keepTopRanked_',",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," 
            where translateIdToKeep is null;
	");
    
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

    set @stmt = concat("truncate table ", @listTable);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFAtoCon1UpdateSFtoCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where trim(REPLACE(CONVERT(",fieldA," USING ASCII), '?','')) = '",con1,"'
and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 

if (length(con1) = 0) then
	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where (",fieldA," is null or ",fieldA," = '')
	and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 

end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchSFtoCon1UpdateFBtoCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where trim(REPLACE(CONVERT(",srcField," USING ASCII), '?','')) = '",con1,"'
				and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (length(con1) = 0) then
		set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where (",srcField," is null or ",srcField," = '')
		and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt; 
    
end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mergeTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


set @con1 = concat('F', con1);
set @con2 = concat('F', con2);


set @stmt = concat("update ",@translatedTable," set forcw = concat_ws('', ",fieldA,", '_', ",fieldB,", '_', ",@con1,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;  


set @stmt = concat("update ",@translatedTable," tt 
join  (select group_concat(",@con2,") mser, forcw from ",@translatedTable," group by forcw)  ms on ms.forcw = tt.forcw set ",@con2," =ms.mser;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


set @stmt = concat("delete table1 from    ",@translatedTable," table1  left join (SELECT id as idsToKeep FROM ",@translatedTable," tt
						INNER JOIN (SELECT forcw, min(id) AS keepId FROM ",@translatedTable,"  GROUP BY forcw) groupedtt 
						ON tt.forcw = groupedtt.forcw  AND tt.id = groupedtt.keepId ) keepIds
                        on keepIds.idsToKeep = table1.id where idsToKeep is null;
                        ");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mergeValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @con1 = concat('F', con1);
set @con2 = concat('F', con2);


set @stmt = concat("update ",@translatedTable," set forcw = concat_ws('', ",fieldA,", '_', ",fieldB,", '_', ",@con1,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;  


set @stmt = concat("update ",@translatedTable," tt 
join  (select group_concat(",@con2,") mser, forcw from ",@translatedTable," group by forcw)  ms on ms.forcw = tt.forcw set ",@con2," =ms.mser;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `NumericRange`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @startRange = con1;
set @endRange = con2;


/** make sure start range, end range and con1 ( ) are all numeric **/
		if ( 
		@startRange REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 ||
		@endRange REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 ||
		length(@startRange) = 0 || length(@endRange) = 0
		) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'NumericRange Macro - One of these is not a valid value.  Start Range - ",@startRange," or End Range - ",@endRange,". '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;



	set @whereStmt =  concat("and ",srcField ," is not null and length(",srcField,") > 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	

	-- error out all non numeric values transactions
    set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where ",srcField," REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 "
    , @whereStmt);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
      
    /**
    now we compare if value is between startRange and endRange, we insert error if it is not **/
    set @stmt = concat("update  ", @translatedTable , " set forcw ='MACRO_ERROR'
    where ",srcField," not between ",@startRange," and ", @endRange,
    " and (forcw is null or forcw != 'MACRO_ERROR') ", @whereStmt);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

    
    
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `overwriteSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

	 set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con1, "' 
     where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `overwriteSFWithRandomNumber`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

declare _rc varchar(255);
begin
	set _rc = cast(FLOOR(1000000000 + (RAND() * 8999999999)) AS char);
    select _rc;
             
end; 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",_rc, "' 
    where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `pastDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'pastDateCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- we expect 4 digit years
	set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,1) != '-'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = '';

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
length(",srcField,") > 0 and  ",srcField," is not null  
 and (",srcField," >= curdate() - interval ",con1," month  = 0  or  Date(",srcField,") is null)
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateAuditReport`(in inConfigId int, in inBatchId int)
proc_main:begin


SET @stmt = CONCAT('truncate table  transactionindetailauditerrors_',inBatchId);
PREPARE stmt from @stmt;
EXECUTE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT('insert into transactionindetailauditerrors_',inBatchId,' 
(required, batchUploadId, configId, transactionInRecordsId, fieldNo, errorId, transactionInErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.required, a.batchUploadId,a.configId,a.transactionInRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactioninerrors_',inBatchId,' a inner join 
transactioninrecords_',inBatchId,' b on a.transactionInRecordsId = b.id
where a.configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,' JOIN (select distinct fieldNo matchid, macro_Name as label 
from macro_names, transactioninerrors_',inBatchId,' where macro_Names.id = transactioninerrors_',inBatchId,'.macroId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionindetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, name as label 
from crosswalks, transactioninerrors_',inBatchId,' where crosswalks.id = transactioninerrors_',inBatchId,'.cwId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, validationType as label 
from ref_validationtypes, transactioninerrors_',inBatchId,' where ref_validationtypes.id = transactioninerrors_',inBatchId,'.validationTypeId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('insert into transactionindetailauditerrors_',inBatchId,' 
(batchUploadId, configId, transactionInRecordsId, fieldNo, errorId, transactionInErrorId,errorData, required)
select batchUploadId,configId,0,fieldno,errorId,id,stackTrace, required from transactioninerrors_',inBatchId,' 
where errorId = 5 and configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionindetailauditerrors_",inBatchId," 
where batchUPloadId = ",inBatchId,"  and errorData is null and configId = ",inConfigId," into @fieldNos;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (@fieldNos is not null) then

	begin
    
    SET @stmt = CONCAT("
		select distinct group_concat(distinct concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionindetailauditerrors_",inBatchId,"
        where batchUPloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
	 ");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
   if (@updateStmts is not null) then 
    begin
   
	   SET @stmt = CONCAT("
			update transactionindetailauditerrors_",inBatchId," tiae join (
			select id, ", @fieldNos," from transactioninrecords_",inBatchId,") tir
			on tiae.transactionInRecordsId = tir.id
			set errordata = case ",@updateStmts," end
			where batchUPloadId = ",inBatchId,"  and errorData is null  and configId = ",inConfigId," ;
		");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
	end;
    end if;

	end;

end if;


SET @stmt = CONCAT('INSERT INTO batchuploadauditerrors (batchuploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber, required) 
select batchUploadId, configId, table1.fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId, required 
from transactionIndetailauditerrors_',inBatchId, " table1");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("update batchuploadauditerrors table1 join (
select ",@rptField1," fieldData, transactionInRecordsId from transactiontranslatedin_",inBatchId,") table2
on table1.rownumber = table2.transactionInRecordsId
set translatedReportField1Data = fieldData
where table1.batchUploadId = ",inBatchId,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateDroppedValues`(in inConfigId int, in inBatchId int, in foroutboundProcessing boolean)
proc_main:begin

set @dvTableName = "batchuploaddroppedvalues";
set @recordName = "transactioninrecords";
set @batchIdCol = "batchUploadId";
set @colDirection = "in";

if (foroutboundProcessing)  then
		set @dvTableName = "batchdownloaddroppedvalues";
		set @recordName = "transactionoutrecords";
        set @batchIdCol = "batchDownloadId";
        set @colDirection = "out";
end if;


SET @stmt = CONCAT("
delete dropv from transaction",@colDirection,"macrodroppedvalues_",inBatchId," dropv join (
select matchid from transaction",@colDirection,"macrokeptvalues_",inBatchId,") keptv
on keptv.matchId = dropv.matchId;
");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
insert into ",@dvTableName ," (",@batchIdCol,", transaction",@colDirection,"recordsId, fieldNo, configId, fieldName, fieldValue)
select distinct ",inBatchId,", t1.transaction",@colDirection,"recordsId, t1.fieldNo, t1.configId, fieldDesc, 
t1.fieldValue from transaction",@colDirection,"macrodroppedvalues_",inBatchId," t1 
join (select * from configurationformfields) t2
on t1.configId = t2.configId
and t1.fieldNo = t2.fieldno;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (foroutboundProcessing) then
	begin
		
         select batchuploadid into @batchUploadId from batchdownloads where id = inBatchId;
        delete from   batchdownloaddroppedvalues where batchuploadId = @batchUploadId;
    
        
        SET @stmt = CONCAT("
			update  batchdownloaddroppedvalues t1 join (select id transactionOutRecordsId, transactionInRecordsId from transactionoutrecords_",inBatchId," 
            ) t2
			on t1.transactionOutRecordsId = t2.transactionOutRecordsId
			set t1.batchuploadId = ",@batchUploadId,",
            t1.transactionInRecordsId = t2.transactionInRecordsId
            where t1.batchdownloadId = ",inBatchId,";
		");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

        
	end;
end if;

select concat('F', fieldNo) into @entity3IdField from configurationformfields where configId = inConfigId and fieldDesc = 'rrEntity3' limit 1;


SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;



if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


if(@entity3IdField is null) then 
	set @entity3IdField = "F1";
end if;


SET @stmt = CONCAT("
update  ",@dvTableName," t1 join 
(Select transaction",@colDirection,"RecordsId, t1.",@rptField1," rptField1, t1.",@rptField2," rptField2, t1.",@rptField3," rptField3, t1.",@rptField4," rptField4, 
rrEntity3Id from transaction",@colDirection,"records_",inBatchId," t1 join
(select ",@entity3IdField," rrEntity3Id, transaction",@colDirection,"RecordsId from transactiontranslated",@colDirection,"_",inBatchId,") t2
on t1.id = t2.transaction",@colDirection,"RecordsId) t2
on t1.",@recordName ,"Id = t2.",@recordName,"Id 
set reportField1Data = rptField1,
reportField2Data = rptField2,
reportField3Data = rptField3,
reportField4Data = rptField4,
translatedReportField1Data = rptField1 
where t1.",@batchIdCol," = ",inBatchId," and configId = ",inConfigId,";
");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `PopulateFPRaceIdAndFields`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;
			
            set @whereString = concat("  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
			
            
            -- we need to keep original value, store it in forcw first
            set @stmt = concat("
				update ",@translatedTable, " set forcw = ",srcField,";
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt; 
            
			set @stmt = concat("
				select length(concat_ws('', F17,F18,F19,F20,F21,F22,F23,F30)) fieldLen from ",@translatedTable, @whereString, " order by fieldLen desc limit 1 into @fieldLen;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
         
    
        if (@fieldLen = 0) then
    
    
		begin
				set @stmt = concat("update ",@translatedTable," set F17 = case when concat(',', ",srcField,", ',') like '%,1,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
				set @stmt = concat("update ",@translatedTable," set F18 = case when concat(',', ",srcField,", ',') like '%,2,%' then '",con1,"' else '' end",@whereString,";");
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
				set @stmt = concat("update ",@translatedTable," set F19 = case when concat(',', ",srcField,", ',') like '%,3,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F20 = case when concat(',', ",srcField,", ',') like '%,4,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F21 = case when concat(',', ",srcField,", ',') like '%,5,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F22 = case when concat(',', ",srcField,", ',') like '%,7,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F23 = case when concat(',', ",srcField,", ',') like '%,6,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F30 = case when concat(',', ",srcField,", ',') like '%,8,%' then'",con1,"'  else '' end ",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
	
    end;
    
    end if;
				
                set @stmt = concat("
				update ",@translatedTable," set ",srcField," =  case 
				when ( length(concat_ws('', F17,F18,F19,F20,F21,F23)) > 1)  and  (length(concat_ws('', F22, F30)) = 0) then 6 
				when (F22 = '",con1,"' and length(concat_ws('', F17,F18,F19,F20,F21, F23, F30)) = 0) then 7
				when (F30 ='",con1,"' and length(concat_ws('', F17,F18,F19,F20, F21, F23, F22)) = 0) then 8
				when (F17 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 1  when (F18 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 2 
				when (F19 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 3 when (F20 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 4 
				when (F21 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 5 when (F23 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)  then 6
				else '' end ",@whereString,"
			");
            
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
			   
				-- put back forcw value so it can be passed
                -- track the ids that are changed
                
                set @errorIds = '';
                
                set @stmt = concat("
				select  group_concat(id) from ",@translatedTable, "
                where length(forcw) > 0 and (",srcField," is null or length(",srcField,") = 0)
				into @errorIds");
                
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt; 
                
                if (@errorIds is not null) then 
                
					begin
						set @stmt = concat("
						update ",@translatedTable, " set ",srcField," = forcw
						where id in (",@errorIds,")");
				
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
						
						set @stmt = concat("
						update ",@translatedTable, " set forcw = 'MACRO_ERROR'
						where id in (",@errorIds,")");
			
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
					
					end;
                end if;
                
                
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateOutboundAuditReport`(in inConfigId int, in inBatchId int, in inBatchUpoadId int, in inBatchUploadConfigId int)
proc_main:begin

SET @stmt = CONCAT('delete from transactionoutdetailauditerrors_',inBatchId,' where configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

SELECT populateInboundAuditReport INTO @populateInboundAuditReport
FROM configurationtransportdetails where configId = inConfigId LIMIT 1;


if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT('insert into transactionoutdetailauditerrors_',inBatchId,' 
(required, batchDownloadId, configId, transactionOutRecordsId, fieldNo, errorId, transactionOutErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.required, a.batchDownloadId,a.configId,a.transactionOutRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactionouterrors_',inBatchId,' a inner join 
transactionoutrecords_',inBatchId,' b on a.transactionOutRecordsId = b.id
where a.configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("UPDATE transactionouterrors_",inBatchId," JOIN (select distinct id as matchId, macro_Name as label 
from macro_names) tbl_concat
 ON transactionouterrors_",inBatchId,".macroId = tbl_concat.matchid
SET transactionouterrors_",inBatchId,".stackTrace = concat(label, ' - ' , stackTrace) WHERE errorId = 5");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,' JOIN (select distinct fieldNo matchid, macro_Name as label 
from macro_names, transactionouterrors_',inBatchId,' where macro_Names.id = transactionouterrors_',inBatchId,'.macroId) tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
 JOIN (select distinct fieldNo matchid, name as label 
from crosswalks, transactionouterrors_',inBatchId,' where crosswalks.id = transactionouterrors_',inBatchId,'.cwId) tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
 JOIN (select distinct fieldNo matchid, validationType as label 
from ref_validationtypes, transactionouterrors_',inBatchId,' where ref_validationtypes.id = transactionouterrors_',inBatchId,'.validationTypeId) tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
 JOIN (select distinct fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



SET @stmt = CONCAT('insert into transactionoutdetailauditerrors_',inBatchId,' 
(required, batchDownloadId, configId, transactionOutRecordsId, fieldNo, errorId, transactionOutErrorId,errorData)
select required, batchDownloadId,configId,0,fieldno,errorId,id,stackTrace
from transactionouterrors_',inBatchId,' 
where errorId = 5 and configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionoutdetailauditerrors_",inBatchId," 
where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @fieldNos;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;




if (@fieldNos is not null) then

	begin

 SET @stmt = CONCAT("
 select distinct group_concat(distinct concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionoutdetailauditerrors_",inBatchId,"
 where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;


 if (@updateStmts is not null) then 
 begin

 SET @stmt = CONCAT("
 update transactionoutdetailauditerrors_",inBatchId," tiae join (
 select distinct id, ", @fieldNos," from transactionoutrecords_",inBatchId,") tir
 on tiae.transactionoutRecordsId = tir.id
 set errordata = case ",@updateStmts," end
 where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," ;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
	end;
 end if;

	end;

end if;

delete from batchdownloadauditerrors where batchdownloadId = inBatchid and configId = inConfigId;


SET @stmt = CONCAT('INSERT INTO batchdownloadauditerrors (batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber) 
select batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionOutRecordsId 
from transactionoutdetailauditerrors_',inBatchId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- update report field
SET @stmt = CONCAT("update batchdownloadauditerrors table1 join (
select ",@rptField1," fielddata, transactionOutRecordsId from transactiontranslatedout_",inBatchId,") table2
on table1.rownumber = table2.transactionOutRecordsId
set translatedReportField1Data = fieldData
where table1.batchdownloadId = ",inBatchId,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



if (@populateInboundAuditReport) then

 begin


 call createTempErrorTable(inBatchId);

 SET @stmt = CONCAT("
 insert into transactionoutdetailauditerrorsforinbound_",inBatchId," 
 select * from transactionoutdetailauditerrors_",inBatchId,";
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;


 SET @stmt = CONCAT("
 ALTER TABLE transactionoutdetailauditerrorsforinbound_",inBatchId," 
 ADD COLUMN transactionInRecordsId INT NULL AFTER transactionOutErrorId,
 ADD COLUMN inFieldNo INT NULL AFTER transactionInRecordsId;
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 


 SET @stmt = CONCAT("
 update transactionoutdetailauditerrorsforinbound_",inBatchId," auditTable join (
 select distinct populateErrorFieldNo, mt.* from configurationconnectionfieldmappings join 
 ( select auditId, transactionInRecordsId, fieldno from transactionoutrecords_",inBatchId," tir 
 join ( select id as auditId, transactionoutrecordsId, fieldNo from transactionoutdetailauditerrorsforinbound_",inBatchId,") errorTable 
 on tir.id = errorTable.transactionoutrecordsId) mt on mt.fieldNo = configurationconnectionfieldmappings.fieldNo 
 where sourceConfigId = ",inBatchUploadConfigId,") infoTable
 on infotable.auditid = auditTable.id
 set auditTable.transactionInRecordsId = infoTable.transactionInRecordsId, inFieldNo = populateErrorFieldNo;
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 



 SET @stmt = CONCAT("
 select group_concat(distinct concat('F', inFieldNo)) from transactionoutdetailauditerrorsforinbound_",inBatchId," where infieldNo != 0 into @inboundFields;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 


 if (@inboundFields is not null) then 

 begin

 SET @stmt = CONCAT("
 select group_concat(distinct concat('when infieldNo = ', inFieldNo , ' then ', concat('F', inFieldNo)) separator ' ' ) 
 from transactionoutdetailauditerrorsforinbound_",inBatchId," where infieldNo != 0 into @inUpdateFields;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 


 SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptInField1, @rptInField2,@rptInField3,@rptInField4 
 FROM configurationmessagespecs where configId = inBatchUploadConfigId LIMIT 1;


 if (@rptInField1 = 'F0') then 
 set @rptInField1 = "F1";
 end if;

 if (@rptInField2 = 'F0') then 
 set @rptInField2 = "F2";
 end if;

 if (@rptInField3 = 'F0') then 
 set @rptInField3 = "F3";
 end if;

 if(@rptInField4 = 'F0') then 
 set @rptInField4 = "F4";
 end if;


 SET @stmt = CONCAT("
 update transactionoutdetailauditerrorsforinbound_",inBatchId," tir join (
 select distinct ",@rptInField1," reportField1Data, ",@rptInField2," reportField2Data, ",@rptInField3," reportField3Data, ",@rptInField4," reportField4Data, 
 transactionInRecordsId, ",@inboundFields," from transactioninrecords_",inBatchUpoadId," tir join 
 (select distinct transactionInRecordsId from transactionoutdetailauditerrorsforinbound_",inBatchId,") auditTable
 on transactionInRecordsId = tir.id) infotable
 on infotable.transactionInRecordsId = tir.transactionInRecordsId
 set errorData = case 
 ",@inUpdateFields,"
 end, 
 tir.reportField1Data = infotable.reportField1Data, tir.reportField2Data = infotable.reportField2Data,
 tir.reportField3Data = infotable.reportField3Data, tir.reportField4Data = infotable.reportField4Data
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 

 -- SET @stmt = CONCAT("
 -- delete from batchuploadauditerrors where fromOutboundConfig = true and batchUploadId = ",inBatchUpoadId," and configId = ",inBatchUploadConfigId,"
 -- ");

 -- PREPARE stmt from @stmt;
 -- EXECUTE stmt;
 -- DEALLOCATE PREPARE stmt;


 -- SET @stmt = CONCAT("insert into batchuploadauditerrors (batchUploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 -- reportField2Data, reportField3Data, reportField4Data, rownumber, fromOutboundConfig, required)
 -- select ",inBatchUpoadId,", ",inBatchUploadConfigId,", case when inFieldNo is null then 0 else inFieldNo end, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 -- reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId, true, required from 
 -- transactionoutdetailauditerrorsforinbound_",inBatchId, " table1");

 -- PREPARE stmt from @stmt;
 -- EXECUTE stmt;
 -- DEALLOCATE PREPARE stmt; 

 end;
 end if;

 SET @stmt = CONCAT("
 delete from batchuploadauditerrors where fromOutboundConfig = true and batchUploadId = ",inBatchUpoadId," and configId = ",inBatchUploadConfigId,"
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;


 SET @stmt = CONCAT("insert into batchuploadauditerrors (batchUploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 reportField2Data, reportField3Data, reportField4Data, rownumber, fromOutboundConfig, required)
 select ",inBatchUpoadId,", case when inFieldNo is null then configId when inFieldNo = 0 then configId else ",inBatchUploadConfigId," end, case when inFieldNo is null then fieldNo when inFieldNo = 0 then fieldNo else inFieldNo end, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 reportField2Data, reportField3Data, reportField4Data, case when transactionInRecordsId is null then 0 else transactionInRecordsId end, true, required from 
 transactionoutdetailauditerrorsforinbound_",inBatchId, " table1");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 
 
  -- update translatedReportField1Data
           SET @stmt = CONCAT("update batchuploadauditerrors table1 join (
			select ",@rptInField1 ," fieldData, transactionInRecordsId from transactiontranslatedin_",inBatchUpoadId,") table2
			on table1.rownumber = table2.transactionInRecordsId
			set translatedReportField1Data = fieldData
			where table1.batchUploadId = ",inBatchUpoadId," and fromOutboundConfig = true;");

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
 

 SET @stmt = CONCAT("drop table if exists transactionoutdetailauditerrorsforinbound_",inBatchId,"; ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 

 end;
end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `prependCon2IfCon1Length`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'prependCon2IfCon1Length Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 = 0) then
	set @whereClause = concat(" or ",srcField," is null");
end if;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = concat_ws('','", con2, "', ",srcField , ") where (length(",srcField,") = ",con1,@whereClause,") and ",
"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `regExCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;


set @whereClause  = concat("  (",srcField," REGEXP '",con1,"' != 1 or ",srcField," REGEXP '^[",con1,"]*$' is null)
            and ",srcField," is not null and  length(",srcField,") > 0 and ");
            
set @whereString = concat(@whereClause, "  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

			set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR'  where ",@whereString);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `removeDupFromList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


if (transactionId = 0) then
	set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat(" and ",	@transactionTable,"Id = ", transactionId,";");
end if;


set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("delete from ", @listTable," where fcol = ",@fcol," and ",@batchIdType," = ", batchId ,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



	set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)) value, ",@fcol,"
    FROM ",@translatedTable ," t CROSS JOIN (
    SELECT a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=50) a
   ,(select id N from ref_numbers where id <=50) b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
    
    
    set @stmt2 = "";
	set @stmt1 = concat("update ",@listTable,"  set translatedvalue = invalue where ",@batchIdType," = ", batchId);
    if (transactionId != 0) then
		set @stmt2 = concat(" and ", @translateCol , " = ", transactionId);
	END if;
	
    set @stmt = concat(@stmt1, @stmt2);
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
  
	set @selDistinct = ' distinct ';

    set @stmt1 = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by translatedValue) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	
    set @stmt2="";
	
    if (passClear = 1) then
		set @stmt2= " where label is not null";
	end if;
	
    set @stmt = concat(@stmt1, @stmt2);
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


select '';
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `replaceBlanksWithChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '" ,con1,  "' where (",srcField, " is null  
	or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and 
	configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `replaceCon1CharswithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

			if (length(con1) = 0) then
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'replaceCon1CharswithCon2 Con1 - ",con1,"  cannot be blank'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
				leave proc_main;
            end if;



            set @stmt = concat("update ", @translatedTable, " set ",srcField," = replace_ci(",srcField,", '",con1,"','",con2,"') 
			where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
				
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `setInboundOutBoundTables`(in foroutboundProcessing boolean, in batchId int)
proc_main:begin


set @translatedTable = CONCAT('transactiontranslatedin_',batchId);
set @transactionTable = CONCAT('transactioninrecords_',batchId);
set @batchTable = "batchUploads";
set @batchIdType = "batchUploadId";
set @errorTable = CONCAT('transactioninerrors_',batchId);
set @batchIdColumn = "batchUploadId";
set @listTable = CONCAT('transactiontranslatedlistin_',batchId);
set @translateCol = "transactioninrecordsid";

if (foroutboundProcessing) THEN
	BEGIN 
	set @translatedTable = CONCAT('transactiontranslatedout_',batchId);
	set @transactionTable = CONCAT('transactionoutrecords_',batchId);
	set @batchTable = "batchDownloads";
	set @batchIdType = "batchDownloadId";
	set @errorTable = CONCAT('transactionouterrors_',batchId);
	set @batchIdColumn = "batchDownloadId";
	set @listTable = CONCAT('transactiontranslatedlistout_',batchId);
	set @translateCol = "transactionoutrecordsid";
	END; 
END IF;
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `setSqlForConfig`(in inConfigId int, in batchUploadId int)
proc_main:begin
SET SESSION group_concat_max_len = 100000;
drop TEMPORARY TABLE if exists temp1;
CREATE TEMPORARY TABLE temp1
as (select min(fieldNo) as fieldNo, saveToTableName, savetotablecol, configId, batchUploadId
from configurationFormFields where configId = inConfigId
and saveToTableName != ''
group by savetotablecol, saveToTableName);
SELECT  batchUploadId, saveToTableName, 
group_concat(distinct savetotablecol ORDER BY fieldNo SEPARATOR ',') as savetotablecol,
group_concat( concat('F',fieldNo) ORDER BY fieldNo SEPARATOR ',') as singleValueFields, 
group_concat( concat('strSplit(F',fieldNo, ', ''^^^^^'',@valPos)') ORDER BY fieldNo SEPARATOR ',') as splitFields, 
group_concat( concat('F',fieldNo, ' like ''%^^^^^%''') ORDER BY fieldNo SEPARATOR ' or ') as checkForDelim,
configId
FROM temp1 
where configId = inConfigId
GROUP BY saveToTableName
ORDER BY saveToTableName;
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `setSqlForOutboundConfig`(in inConfigId int, in batchDownloadId int)
proc_main:begin
SET SESSION group_concat_max_len = 10000;
drop TEMPORARY TABLE if exists tempOut;
CREATE TEMPORARY TABLE tempOut
as (select min(fieldNo) as fieldNo, saveToTableName, savetotablecol, configId, batchDownloadId
from configurationFormFields where configId = inConfigId
and saveToTableName != ''
group by savetotablecol, saveToTableName);
select batchDownloadId, 
group_concat(fieldNo ORDER BY fieldNo SEPARATOR ',')as fieldNos, 
group_concat(savetotablecol ORDER BY fieldNo SEPARATOR ',') as saveToCols
, saveToTableName, group_concat(
concat(
'group_concat(COALESCE(',savetotablecol, ', null) order by ', saveToTableName, '.id separator ''^^^^^'' ) as ', savetotablecol
) 
ORDER BY fieldNo SEPARATOR ', ')  as selectFields, 
group_concat(concat('tto.f', fieldNo, ' = selectTbl.' , savetotablecol)  ORDER BY fieldNo SEPARATOR ', ')  as updateFields,
configId
FROM tempOut
where configId = inConfigId
GROUP BY saveToTableName
ORDER BY saveToTableName;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stringToDate`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');

		set @inboundDateFormat = con1;
        
		if (length(con2) > 0) then
			set @outboundDateFormat = concat(con2);
		else 
			set @outboundDateFormat = concat('%Y-%m-%d');
		end if;



		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

	if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
						
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
	end if;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      


	set @errorIds = "";
	set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin	
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

	
set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		
		if (@goodIds is not null) then

			begin
					-- fix two digit years
					-- check to make sure %y is in the inbound to handle
                    select year(curdate()) into @currYear;
                    
					if  (@inboundDateFormat like BINARY '%\%y%' && @outboundDateFormat not like BINARY '%\%y%') then 
					
					select year(curdate()) into @currYear;

					set @stmt = concat("update ",@translatedTable, " set ",srcField," =  DATE_ADD(",srcField,", INTERVAL -100 Year) where id in (",@goodIds,") 
					and year(",srcField,") > ",@currYear,"");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                    
                    -- translate to final format
                    set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
		end if;
                    
			end;
		end if;
        
        

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripCharAtPos`(in configId int, 
in batchId int, in srcField varchar(10), in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- check to see if con1 is numeric
      if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharAtPos Con1 - ",con1,"  must be a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;

set @readField = srcField;
set @strCompare = '';


if (length(trim(con2)) != 0) then
	begin 
		set @strCompare = concat(" and substring(", @readField, ",", con1, ", 1) = '", con2, "'");
	end;
end if; 


select @readField;

set @stmt = concat("update ",@translatedTable, " set ",srcField," = concat(substring(", @readField,", 1, (", con1, "-1)), 
substring(", @readField, ", (", con1, " + 1),length(", @readField,")- ", con1,")) where length(", @readField,") >= " ,con1 , 
@strCompare, "  and  configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripCharsFromStartOrEnd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharsFromStartOrEnd Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

if (length(con2) = 0) then

	set con2 = 2;

end if;

if (con2 != 1 && con2 != 2 && length(con2) != 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharsFromStartOrEnd Macro - Con2 - ",con2," should be 1 or 2. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
leave proc_main;

end if;

		set @stripSQL = concat("substring(",srcField,", ",con1+1,", length(",srcField,"))");
		if (con2 = 2) then 
		set @stripSQL = concat("substring(",srcField,", 1, length(",srcField,")-",con1,")");
		end if;

		set @stmt = concat("update ",@translatedTable, " set ",srcField," = " ,@stripSQL,  " where 
		configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripLeadingChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("update ", @translatedTable," updateTable join 
(select id, TRIM(LEADING '",con1,"' FROM ",srcField,") as updateTo from ", @translatedTable," where 
left(",srcField,", length('",con1,"')) = '",con1,"' and  configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")) tti
on tti.id = updateTable.id
set updateTable.",srcField," = updateTo  
where  configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripPhoneChars`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN
	DECLARE varToReplace varchar(100) DEFAULT '.';
	DECLARE part1 varchar(255) DEFAULT '.';
	DECLARE part2 varchar(25) DEFAULT '.';
    DECLARE part3 varchar(253) DEFAULT '.';
	
	BEGIN
		set part1 = concat("update transactiontranslatedin_",batchUploadId," SET F", fieldNo, " = replace(F", fieldNo, ", '");
		set part3 = concat(" where configId = ",configId," and batchUploadId = ", batchUploadId , " and statusId not in (11,12,13,16,20);");
	END;

	set part2 = "', '')";
    
	set @stmt = concat(part1, varToReplace, part2, part3);
  	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '-';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ')';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '(';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ' ';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

 END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripPhoneCharsOutbound`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN
	DECLARE varToReplace varchar(100) DEFAULT '.';
	DECLARE part1 varchar(255) DEFAULT '.';
	DECLARE part2 varchar(25) DEFAULT '.';
    DECLARE part3 varchar(253) DEFAULT '.';
	
	if (transactionId = 0) then
	BEGIN
		set part1 = concat("update transactiontranslatedout_",batchUploadId," SET F", fieldNo, " = replace(F", fieldNo, ", '");
		set part3 = concat(" where configId = ",configId," and batchDownloadId = ", batchUploadId , " and statusId not in (11,12,13,16, 20);");
	END;
	END if;

	if (transactionId != 0) then
	BEGIN
	  set part1 = concat("update transactiontranslatedout_",batchUploadId," SET transactiontranslatedOut.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
      set part3 = concat(" where transactionOutRecordsId = ", transactionId);
	END;
	END if;
	
	set part2 = "', '')";
    
	set @stmt = concat(part1, varToReplace, part2, part3);
  	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '-';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ')';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '(';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ' ';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

 END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripTrailingChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = TRIM(TRAILING '",con1,"' FROM ",srcField,") where configId = ",configId, 
" and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `substringToAnotherField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

	-- check to make sure con1 and con2 are numeric
    
	if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 or   con2 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'substringToAnotherField macro Either - Con1 - \"",con1,"\"  or Con2 - \"",con2,"\" is not a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;

		set @stmt = concat("update ",@translatedTable, " set ",fieldA," =  ",
		" substring(" , srcField, ", ", con1,",", con2,")  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `yearDiffinsertError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'DOBCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and (
                    (length(",srcField,") = 0 and  length(",fieldA,") > 0)
                    or 
                    (length(",fieldA,") = 0 and  length(",srcField,") > 0)
                    or 
                    (",fieldA," is null and  length(",srcField,") > 0)
                    or 
					(",srcField," is null and  length(",fieldA,") > 0)
                    or  ( length(",srcField,") > 0 and substring(",srcField,",5,1) != '-' )
                    or (length(",fieldA,") > 0 and substring(",fieldA,",5,1) != '-')
                    )
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- now we find the ones that are not valid
set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)  or  (Date(",fieldA,") is null and length(",fieldA,") > 0 ))
 or (YEAR(",fieldA,") - YEAR(",srcField,") < ",con1,") 
 or (
 YEAR(",fieldA,") - YEAR(",srcField,") - (DATE_FORMAT(",fieldA,", '%m%d') < DATE_FORMAT(",srcField,", '%m%d')) < ",con1,"
 )
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ZipCodeCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

				
                set @proceed = true;
                
                
                if (length(con1) > 0) then
					begin
						
                        if con1 REGEXP '^[0-9]{5}$' = 0 then 
                        
							set @proceed = false;
                            
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'Default zip code ",con1," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                            leave proc_main;
						end if;
					end;
                end if;

				if (@proceed) then 
								begin
								
								set @whereStmt =  concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
								set @whereClause = concat("  (",srcField," REGEXP '^[0-9]{5}$' != 1) 
								and ",srcField," is not null and length(",srcField,") > 0 ");
							    set @whereString = concat(@whereClause , @whereStmt);

								set @stmt = concat("update  ", @translatedTable , " set forcw = ",srcField);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;

								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = replace(",srcField,", '-', '') where (length(", srcField,") != 0 or ",srcField," is not null )", @whereStmt);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
								
								
								
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = 
								case 
								when (length(",srcField,") = 4 or length(",srcField,") = 8) then concat('0', ",srcField,") 
								when (length(",srcField,") = 3 or length(",srcField,") = 7)  then concat('00', ",srcField,") 
								when (length(",srcField,") = 2  or length(",srcField,") = 6)  then concat('000', ",srcField,") 
								when length(",srcField,") = 1 then concat('0000', ",srcField,") 
								else ",srcField," end where length(",srcField,") != 5 ", @whereStmt);
								
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = left(",srcField,", 5) where length(", srcField,") > 5", @whereStmt);
								 
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
                                
								
								set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where  ", @whereString);
                               
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								if (length(con1) > 0) then
												
													set @stmt = concat("update  ", @translatedTable , " set forcw='BlankVar', ",srcField," = '",con1,"' where (length(", srcField,") = 0 or ",srcField," is null )  ", @whereStmt);
													
                                                    PREPARE stmt from @stmt;
													EXECUTE stmt;
													DEALLOCATE PREPARE stmt;
								end if;
							   
				

			end;
	end if;
				
end proc_main$$
DELIMITER ;



